var methodMap = {
    "create": "POST",
    "update": "PUT",
    "delete": "DELETE",
    "read"  : "GET"
};

var cachedAttributes = {
	"listPositionByCategory" : true,
	"listPositionByDueDate" : true,
	"listPositionByPriority" : true,
	"categoryCollapsed" : true,
    "linkUrl": true
};

var volatileAttributes = {
	"taskExpanded" : true
};

define([
	"jquery",
	"underscore",
	"backbone",
	"constants",
	"base64",
	"server/auth"
], function($, _, Backbone,
			Constants,
			Base64,
			Auth
	) {

    function bindAjaxErrorHandler(){
<<<<<<< HEAD
        var latestFailedRequest;

        $(".server-error .try-again").on("click", function(){
            location = location;
        });


        $(document).ajaxError(function(event, jqxhr, settings, exception) {
            if(jqxhr.status == 503) {
                latestFailedRequest = jqxhr;
=======
        $(".server-error .try-again").on("click", function(){
            location.reload();
        });

        $.ajaxSetup({
            timeout: 4000
        });

        $(document).ajaxError(function(event, jqxhr, settings, exception) {
            console.log("server error", jqxhr, exception, jqxhr.statusText);
            if(jqxhr.status >= 500 || jqxhr.statusText == "timeout") {
>>>>>>> hotfix-servererrors
                $(".server-error").addClass("show");
            }
        });
    }

    bindAjaxErrorHandler();

	function createGlobalId()  {
		var randomString = "";
		for(var i = 0; i < 16; i++) {
			randomString += String.fromCharCode(Math.random() * 256);
		}
		return Base64.encodeBase64(randomString).replace(/\//g,"_").replace(/\+/g,"-");
	}

	function sync(method, model, options) {
		// Backbone either gives us model.url as a string or as a function.
		// now that's what I call bad programming.

		var fullUrl = ((typeof model.url) == "string" ? model.url : model.url());
		var shouldSync = true;
		fullUrl += "?responseType=flat&includeDeleted=false&includeDone=false";

		var params = _.extend({
			type: methodMap[method],
			dataType: "json",
			url: fullUrl,
			xhrFields: {
				withCredentials: true
			},
			crossDomain: true
		}, options);

		if (model && (method == "create" || method == "update")) {
			params.contentType = "application/json";

			// we generate our own IDs as global IDs.
			// From now on, the model is marked as "created" and will
			// only receive "update" and "delete" requests.
			if (method == "create") {
				var id = createGlobalId();
				model.set({"id": id});
			}

			var jsonData = model.toJSON();

			if (method == "update") {
				shouldSync = false;
			}

			for (var attribute in jsonData) {
				if (cachedAttributes[attribute]) {
                    window.storage.setItem(model.get("id") + ":" + attribute, JSON.stringify(model.get(attribute)));
				} else {
					/*
					if (jsonData[attribute] == null) {
						delete jsonData[attribute];
						console.log("deleted attribute: " + attribute);
						shouldSync = true;
						continue;
					}
					*/

					if (model.get(attribute) != model.previous(attribute) && method == "update" && attribute != "id") {
						if (volatileAttributes[attribute]) {
							continue;
						}
						// console.log("found new attribute to sync: " + attribute, "old:", model.previous(attribute), "new:", model.get(attribute), "model:", model);
						shouldSync = true;
					}
				}
			}

			if (method == "create") {
				// TODO: make POST support creating a single object instead of a list
				params.data = JSON.stringify([jsonData]);
			} else {
				params.data = JSON.stringify(jsonData);
			}

		}

		if (!shouldSync) {
			options.success();
			return;
		}

		var successCallback = params["success"];

		// override the success function to add the cached attributes
		params["success"] = function(data, status, xhr) {
			var updateModel = function(attributes) {
				if (!attributes) return;
				for (var cachedAttribute in cachedAttributes) {
					if (typeof attributes[cachedAttribute] == "undefined") {
                        attributes[cachedAttribute] = JSON.parse(window.storage.getItem(attributes["id"] + ":" + cachedAttribute));
					}
				}
			};

			// we should deal both with a single object and arrays
			if (data instanceof Array) {
				// Backbone doesn't deal with creating with lists, only one object at a time
				if (method == "create") {
					data = data[0];
					updateModel(data);
				} else {
					for (var item = 0; item < data.length; item++) {
						updateModel(data[item]);
					}
				}
			} else {
				updateModel(data);
			}

			return successCallback(data, status, xhr);
		};

		var errorCallback = params["error"];
		params["error"] = function(data, status, xhr) {
			if (status == "parsererror") {
				Auth.logInUsingStoredCredentials(function() {
					// TODO: make a more generic refresh function?
					if (typeof chrome != "undefined") {
						// console.log("refreshing after logging in...");
						chrome.runtime.sendMessage({"action" : "refresh"});
					}
				}, function() {
					Auth.logOut();
				});
			} else if (status == 409) {
				Auth.logOut();
			} else {
				errorCallback(data, status, xhr);
			}
		};

		return $.ajax(params);
	}

	// set the default Backbone sync function to ours.
	Backbone.sync = sync;

	return {
		sync: sync,
		createGlobalId: createGlobalId
	}

});


